<p>Okay this is the embed part.</p>

<style type="text/css">
  div.example { display: flex; flex-direction: column; align-items: center; }
</style>

<div class="example" id="example-one">
  <canvas style="image-rendering: pixelated; width: 512px; height: 256px;" width="128" height="64"></canvas>
  <input type="range" autocomplete="off" value="0" min="0" max="1" step="0.001" />
</div>

<script type="text/javascript">
document.addEventListener('DOMContentLoaded', () => {
  exampleOne(document.getElementById('example-one'));
});

function exampleOne(root) {
  const canvas = root.querySelector('canvas');
  const rotation = root.querySelector('input');

  const bauble = new Bauble(canvas, {
    "source": "#version 300 es\nprecision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nout vec4 frag_color;\n\nuniform float rotation;\nuniform int camera_type;\nuniform vec3 free_camera_target;\nuniform vec2 free_camera_orbit;\nuniform float free_camera_zoom;\nuniform vec2 origin_2d;\nuniform float t;\nuniform vec4 viewport;\n\nmat2 rotation_2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat max_(vec2 v) {\n  return max(v.x, v.y);\n}\n\nmat3 rotation_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 perspective_vector(float fov, vec2 frag_coord) {\n  float cot_half_fov = tan(radians(90.0 - (fov * 0.5)));\n  return normalize(vec3(frag_coord, cot_half_fov));\n}\n\nfloat sdf_torus_x(float radius, float thickness, vec3 p) {\n  vec2 other_axes = p.zy;\n  float this_axis = p.x;\n  return length(vec2(length(other_axes) - radius, this_axis)) - thickness;\n}\n\nfloat move_outer(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 25.0);\n    return sdf_torus_x(50.0, 25.0, p1);\n  }\n}\n\nfloat sdf_torus_z(float radius, float thickness, vec3 p) {\n  vec2 other_axes = p.xy;\n  float this_axis = p.z;\n  return length(vec2(length(other_axes) - radius, this_axis)) - thickness;\n}\n\nfloat move_outer1(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * -25.0);\n    return sdf_torus_z(50.0, 25.0, p1);\n  }\n}\n\nfloat smooth_min_distance(vec3 p) {\n  float r = 25.0;\n  float nearest = move_outer(p);\n  float dist = move_outer1(p);\n  float h = (clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5;\n  nearest = mix(nearest, dist, h) - (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat rotate_outer(vec3 p, float rotation, float t) {\n  {\n    vec3 p1 = p * rotation_y(rotation + (t / 10.0));\n    return smooth_min_distance(p1);\n  }\n}\n\nfloat nearest_distance(vec3 p, float rotation, float t) {\n  return rotate_outer(p, rotation, t);\n}\n\nfloat march(out uint steps, Ray ray, float rotation, float t) {\n  float ray_depth = 0.0;\n  for (steps = 0u; steps < 256u; ++steps) {\n    {\n      float depth = ray_depth;\n      vec3 P = ray.origin + (ray_depth * ray.direction);\n      vec3 p = P;\n      float dist = nearest_distance(p, rotation, t);\n      if (((dist >= 0.0) && (dist < 0.1)) || (ray_depth > 65536.0)) return ray_depth;\n      float rate = (dist > 0.0) ? 0.95 : 1.05;\n      ray_depth += dist * rate;\n      if (ray_depth < 0.0) return 0.0;\n    }\n  }\n  return ray_depth;\n}\n\nfloat with_outer(vec3 p, float rotation, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return nearest_distance(p1, rotation, t);\n  }\n}\n\nfloat with_outer1(vec3 p, float rotation, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return nearest_distance(p1, rotation, t);\n  }\n}\n\nfloat with_outer2(vec3 p, float rotation, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return nearest_distance(p1, rotation, t);\n  }\n}\n\nfloat with_outer3(vec3 p, float rotation, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return nearest_distance(p1, rotation, t);\n  }\n}\n\nvec3 do_(vec2 Frag_Coord, vec2 resolution) {\n  const vec3 light = pow(vec3(69.0, 72.0, 79.0) / 255.0, vec3(2.2));\n  const vec3 dark = pow(vec3(40.0, 42.0, 46.0) / 255.0, vec3(2.2));\n  return vec3(mix(dark, light, (Frag_Coord.x + Frag_Coord.y) / (resolution.x + resolution.y)));\n}\n\nfloat fresnel(float exponent, vec3 normal, Ray ray) {\n  return pow(1.0 + dot(normal, ray.direction), exponent);\n}\n\nvec4 sample_(vec2 Frag_Coord, int camera_type, vec2 frag_coord, vec2 free_camera_orbit, vec3 free_camera_target, float free_camera_zoom, vec2 resolution, float rotation, float t) {\n  Ray ray_star = Ray(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n  vec3 ortho_quad = vec3(1024.0, (frag_coord * 212.077343935025) * free_camera_zoom);\n  float ortho_scale = 212.077343935025 * free_camera_zoom;\n  float fov = 0.0;\n  switch (camera_type) {\n  case 0: case 1: {\n    mat3 camera_rotation_matrix = rotation_y(6.28318530717959 * free_camera_orbit.x) * rotation_x(6.28318530717959 * free_camera_orbit.y);\n    ray_star = Ray((camera_rotation_matrix * vec3(0.0, 0.0, 512.0 * free_camera_zoom)) + free_camera_target, camera_rotation_matrix * (perspective_vector(45.0, frag_coord) * vec3(1.0, 1.0, -1.0)));\n    fov = 45.0;\n    break;\n  }\n  case 2: {\n    ray_star = Ray(ortho_quad.yxz + free_camera_target, vec3(0.0, -1.0, 0.0));\n    break;\n  }\n  case 3: {\n    ray_star = Ray(ortho_quad.yzx + free_camera_target, vec3(0.0, 0.0, -1.0));\n    break;\n  }\n  case 4: {\n    ray_star = Ray(ortho_quad.xzy + free_camera_target, vec3(-1.0, 0.0, 0.0));\n    break;\n  }\n  }\n  uint steps = 0u;\n  {\n    Ray ray = ray_star;\n    float depth = march(steps, ray, rotation, t);\n    vec3 P = ray.origin + (ray.direction * depth);\n    vec3 p = P;\n    float dist = nearest_distance(p, rotation, t);\n    vec3 normal = normalize((vec2(1.0, -1.0).xyy * with_outer(p, rotation, t)) + (vec2(1.0, -1.0).yyx * with_outer1(p, rotation, t)) + (vec2(1.0, -1.0).yxy * with_outer2(p, rotation, t)) + (vec2(1.0, -1.0).xxx * with_outer3(p, rotation, t)));\n    vec4 color = vec4(0.0);\n    color = (dist >= 10.0) ? vec4(do_(Frag_Coord, resolution), 1.0) : vec4(mix((normal + 1.0) * 0.5, vec3(1.0, 1.0, 1.0), fresnel(5.0, normal, ray)), 1.0);\n    return color;\n  }\n}\n\nvec3 pow_(vec3 v, float e) {\n  return pow(v, vec3(e));\n}\n\nvoid main() {\n  const float gamma = 2.2;\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  float alpha = 0.0;\n  const uint aa_grid_size = 2u;\n  const float aa_sample_width = 1.0 / float(1u + aa_grid_size);\n  const vec2 pixel_origin = vec2(0.5, 0.5);\n  vec2 local_frag_coord = gl_FragCoord.xy - viewport.xy;\n  mat2 rotation1 = rotation_2d(0.2);\n  for (uint y = 1u; y <= aa_grid_size; ++y) {\n    for (uint x = 1u; x <= aa_grid_size; ++x) {\n      vec2 sample_offset = (aa_sample_width * vec2(float(x), float(y))) - pixel_origin;\n      sample_offset = rotation1 * sample_offset;\n      sample_offset = fract(sample_offset + pixel_origin) - pixel_origin;\n      {\n        vec2 Frag_Coord = local_frag_coord + sample_offset;\n        vec2 resolution = viewport.zw;\n        vec2 frag_coord = ((Frag_Coord - (0.5 * resolution)) / max_(resolution)) * 2.0;\n        vec4 this_sample = clamp(sample_(Frag_Coord, camera_type, frag_coord, free_camera_orbit, free_camera_target, free_camera_zoom, resolution, rotation, t), 0.0, 1.0);\n        color += this_sample.rgb * this_sample.a;\n        alpha += this_sample.a;\n      }\n    }\n  }\n  if (alpha > 0.0) {\n    color = color / alpha;\n    alpha /= float(aa_grid_size * aa_grid_size);\n  }\n  frag_color = vec4(pow_(color, 1.0 / gamma), alpha);\n}\n",
    "animate": true,
    "freeCamera": true,
    "uniforms": {
      "rotation": "float"
    }
  });
  canvas.addEventListener('click', () => {
    bauble.togglePlay();
  });

  rotation.addEventListener('input', (e) => {
    bauble.set('rotation', e.currentTarget.valueAsNumber * Math.PI * 2);
  });
};
</script>
