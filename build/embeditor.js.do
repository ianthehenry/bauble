#!/usr/bin/env bash

redo-ifchange mode rollup
mode=$(cat mode)

actual_outpath_jfc=$PWD/$3

cat >$3 rollup-artifacts/embeditor.js rollup-artifacts/embauble.iife.js <(cat <<EOF
if (!(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)) {
  const balloonExample = () => {
    const canvas = document.getElementById('expandy-balloon');
    const slider = canvas.nextElementSibling;
    const bounceCheckbox = slider.nextElementSibling.querySelector('input');
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;
    const bauble = new Bauble(canvas, {
      source: "#version 300 es\nprecision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nout vec4 frag_color;\n\nuniform float separation;\nuniform int camera_type;\nuniform vec3 free_camera_target;\nuniform vec2 free_camera_orbit;\nuniform float free_camera_zoom;\nuniform vec2 origin_2d;\nuniform float t;\nuniform vec4 viewport;\n\nmat2 rotation_2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat max_(vec2 v) {\n  return max(v.x, v.y);\n}\n\nmat3 rotation_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 perspective_vector(float fov, vec2 frag_coord) {\n  float cot_half_fov = tan(radians(90.0 - (fov * 0.5)));\n  return normalize(vec3(frag_coord, cot_half_fov));\n}\n\nmat3 rotation_z(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 safe_div(vec3 a, vec3 b) {\n  return vec3((b.x == 0.0) ? 0.0 : (a.x / b.x), (b.y == 0.0) ? 0.0 : (a.y / b.y), (b.z == 0.0) ? 0.0 : (a.z / b.z));\n}\n\nfloat atan2(float y, float x) {\n  return (x == 0.0) ? ((0.5 * 3.14159265358979) * sign(y)) : atan(y, x);\n}\n\nfloat atan21(vec2 p) {\n  return atan2(p.y, p.x);\n}\n\nfloat sdf_ellipsoid(vec3 size, vec3 p) {\n  float k0 = length(p / size);\n  float k1 = length(p / (size * size));\n  return (k0 * (k0 - 1.0)) / k1;\n}\n\nfloat sdf_cylinder_y(float radius, float height, vec3 p) {\n  vec2 other_axes = p.xz;\n  float this_axis = p.y;\n  vec2 d = abs(vec2(length(other_axes), this_axis)) - vec2(radius, height);\n  return min(max_(d), 0.0) + length(max(d, 0.0));\n}\n\nfloat move_outer(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, -100.0, 0.0) * 1.0);\n    return sdf_cylinder_y(25.0, 50.0, p1);\n  }\n}\n\nfloat smooth_min_distance(vec3 p) {\n  float r = 50.0;\n  float nearest = sdf_ellipsoid(vec3(50.0, 100.0, 100.0), p);\n  float dist = move_outer(p);\n  float h = (clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5;\n  nearest = mix(nearest, dist, h) - (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat scale_outer(vec3 factor, vec3 p) {\n  {\n    vec3 p1 = p / factor;\n    return smooth_min_distance(p1);\n  }\n}\n\nfloat min_(vec3 v) {\n  return min(v.x, min(v.y, v.z));\n}\n\nfloat map_distance(vec3 factor, vec3 p) {\n  float dist = scale_outer(factor, p);\n  return min_(abs(factor)) * dist;\n}\n\nfloat let_outer(vec3 p) {\n  {\n    vec3 factor = (1.0 - vec3(0.0, 1.0, 0.0)) + (vec3(0.0, 1.0, 0.0) * ((smoothstep(-100.0, 100.0, p.y) * -0.2) + 1.0));\n    return map_distance(factor, p);\n  }\n}\n\nfloat rotate_outer(vec3 p, float parity, vec3 tile_index) {\n  {\n    vec3 p1 = p * rotation_z(((parity * 2.0) - 1.0) * 0.785398163397448);\n    return abs(dot(p1, vec3(0.0, 1.0, 0.0)) - (tile_index.y * 25.0)) - (25.0 * 0.5);\n  }\n}\n\nfloat let_outer1(vec3 p, float radial_index, vec3 tile_index) {\n  {\n    float parity = mod(radial_index, 2.0);\n    return rotate_outer(p, parity, tile_index);\n  }\n}\n\nfloat smooth_min_distance1(vec3 p, float radial_index, vec3 tile_index) {\n  float r = 1.0;\n  float nearest = let_outer(p);\n  float dist = let_outer1(p, radial_index, tile_index);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat with_outer(float angular_size, vec3 p, vec3 tile_index) {\n  {\n    float radial_index = floor(mod(atan21(p.zx) + (angular_size * 0.5), 6.28318530717959) / angular_size);\n    vec3 p1 = rotation_y(-1.0 * angular_size * radial_index) * p;\n    return smooth_min_distance1(p1, radial_index, tile_index);\n  }\n}\n\nfloat let_outer2(vec3 p, vec3 tile_index) {\n  {\n    float count = 12.0;\n    float angular_size = 6.28318530717959 / count;\n    return with_outer(angular_size, p, tile_index);\n  }\n}\n\nfloat move_outer1(vec3 p, vec3 tile_index) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * (tile_index.y * -25.0));\n    return let_outer2(p1, tile_index);\n  }\n}\n\nfloat move_outer2(vec3 p, float separation, vec3 tile_index) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * ((tile_index.y + 1.0) * separation));\n    return move_outer1(p1, tile_index);\n  }\n}\n\nfloat do_(vec3 p, float separation) {\n  vec3 size = vec3(0.0, separation + 25.0, 0.0);\n  vec3 base_index = round(safe_div(p, size));\n  vec3 look_direction = sign(p - (size * base_index));\n  vec3 start_logical = ((vec3(0.0, -2.0, 0.0) * sign(size)) * look_direction) + base_index;\n  vec3 end_logical = ((vec3(0.0, 2.0, 0.0) * sign(size)) * look_direction) + base_index;\n  vec3 start = min(start_logical, end_logical);\n  vec3 end = max(start_logical, end_logical);\n  float nearest = 1000000.0;\n  for (float z = start.z; z <= end.z; ++z) {\n    for (float y = start.y; y <= end.y; ++y) {\n      for (float x = start.x; x <= end.x; ++x) {\n        {\n          vec3 tile_index = vec3(x, y, z);\n          vec3 p1 = p - (size * tile_index);\n          nearest = min(nearest, move_outer2(p1, separation, tile_index));\n        }\n      }\n    }\n  }\n  return nearest;\n}\n\nfloat move_outer3(vec3 p, float separation) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 40.0);\n    return do_(p1, separation);\n  }\n}\n\nfloat rotate_outer1(vec3 p, float separation) {\n  {\n    vec3 p1 = p * rotation_z(1.5707963267949);\n    return move_outer3(p1, separation);\n  }\n}\n\nfloat nearest_distance(vec3 p, float separation) {\n  return rotate_outer1(p, separation);\n}\n\nfloat march(out uint steps, Ray ray, float separation) {\n  float ray_depth = 0.0;\n  for (steps = 0u; steps < 256u; ++steps) {\n    {\n      float depth = ray_depth;\n      vec3 P = ray.origin + (ray_depth * ray.direction);\n      vec3 p = P;\n      float dist = nearest_distance(p, separation);\n      if (((dist >= 0.0) && (dist < 0.1)) || (ray_depth > 65536.0)) return ray_depth;\n      float rate = (dist > 0.0) ? 0.95 : 1.05;\n      ray_depth += dist * rate;\n      if (ray_depth < 0.0) return 0.0;\n    }\n  }\n  return ray_depth;\n}\n\nfloat with_outer1(vec3 p, float separation) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return nearest_distance(p1, separation);\n  }\n}\n\nfloat with_outer2(vec3 p, float separation) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return nearest_distance(p1, separation);\n  }\n}\n\nfloat with_outer3(vec3 p, float separation) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return nearest_distance(p1, separation);\n  }\n}\n\nfloat with_outer4(vec3 p, float separation) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return nearest_distance(p1, separation);\n  }\n}\n\nvec3 pow_(vec3 v, float e) {\n  return pow(v, vec3(e));\n}\n\nfloat fresnel(float exponent, vec3 normal, Ray ray) {\n  return pow(1.0 + dot(normal, ray.direction), exponent);\n}\n\nvec3 with_outer5(vec3 nearest_index, vec3 normal, vec3 p, Ray ray, vec3 size) {\n  {\n    vec3 tile_index = nearest_index;\n    vec3 p1 = p - (size * tile_index);\n    return (mod(tile_index.y, 2.0) == 0.0) ? pow_(mix((normal + 1.0) * 0.5, vec3(1.0, 1.0, 1.0), fresnel(5.0, normal, ray)), 1.5) : mix((normal + 1.0) * 0.5, vec3(1.0, 1.0, 1.0), fresnel(5.0, normal, ray));\n  }\n}\n\nvec3 do_1(vec3 normal, vec3 p, Ray ray, float separation) {\n  vec3 size = vec3(0.0, separation + 25.0, 0.0);\n  vec3 base_index = round(safe_div(p, size));\n  vec3 look_direction = sign(p - (size * base_index));\n  vec3 start_logical = ((vec3(0.0, -2.0, 0.0) * sign(size)) * look_direction) + base_index;\n  vec3 end_logical = ((vec3(0.0, 2.0, 0.0) * sign(size)) * look_direction) + base_index;\n  vec3 start = min(start_logical, end_logical);\n  vec3 end = max(start_logical, end_logical);\n  float nearest = 1000000.0;\n  vec3 nearest_index = vec3(0.0, 0.0, 0.0);\n  for (float z = start.z; z <= end.z; ++z) {\n    for (float y = start.y; y <= end.y; ++y) {\n      for (float x = start.x; x <= end.x; ++x) {\n        {\n          vec3 tile_index = vec3(x, y, z);\n          vec3 p1 = p - (size * tile_index);\n          float dist = move_outer2(p1, separation, tile_index);\n          if (dist < nearest) {\n            nearest = dist;\n            nearest_index = tile_index;\n          }\n        }\n      }\n    }\n  }\n  return with_outer5(nearest_index, normal, p, ray, size);\n}\n\nvec3 move_outer4(vec3 normal, vec3 p, Ray ray, float separation) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 40.0);\n    return do_1(normal, p1, ray, separation);\n  }\n}\n\nvec3 rotate_outer2(vec3 normal, vec3 p, Ray ray, float separation) {\n  {\n    vec3 p1 = p * rotation_z(1.5707963267949);\n    return move_outer4(normal, p1, ray, separation);\n  }\n}\n\nvec4 sample_(int camera_type, vec2 frag_coord, vec2 free_camera_orbit, vec3 free_camera_target, float free_camera_zoom, float separation) {\n  Ray ray_star = Ray(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n  vec3 ortho_quad = vec3(1024.0, (frag_coord * 212.077343935025) * free_camera_zoom);\n  float ortho_scale = 212.077343935025 * free_camera_zoom;\n  float fov = 0.0;\n  switch (camera_type) {\n  case 0: case 1: {\n    mat3 camera_rotation_matrix = rotation_y(6.28318530717959 * free_camera_orbit.x) * rotation_x(6.28318530717959 * free_camera_orbit.y);\n    ray_star = Ray((camera_rotation_matrix * vec3(0.0, 0.0, 512.0 * free_camera_zoom)) + free_camera_target, camera_rotation_matrix * (perspective_vector(45.0, frag_coord) * vec3(1.0, 1.0, -1.0)));\n    fov = 45.0;\n    break;\n  }\n  case 2: {\n    ray_star = Ray(ortho_quad.yxz + free_camera_target, vec3(0.0, -1.0, 0.0));\n    break;\n  }\n  case 3: {\n    ray_star = Ray(ortho_quad.yzx + free_camera_target, vec3(0.0, 0.0, -1.0));\n    break;\n  }\n  case 4: {\n    ray_star = Ray(ortho_quad.xzy + free_camera_target, vec3(-1.0, 0.0, 0.0));\n    break;\n  }\n  }\n  uint steps = 0u;\n  {\n    Ray ray = ray_star;\n    float depth = march(steps, ray, separation);\n    vec3 P = ray.origin + (ray.direction * depth);\n    vec3 p = P;\n    float dist = nearest_distance(p, separation);\n    vec3 normal = normalize((vec2(1.0, -1.0).xyy * with_outer1(p, separation)) + (vec2(1.0, -1.0).yyx * with_outer2(p, separation)) + (vec2(1.0, -1.0).yxy * with_outer3(p, separation)) + (vec2(1.0, -1.0).xxx * with_outer4(p, separation)));\n    vec4 color = vec4(0.0);\n    color = (dist >= 10.0) ? vec4(0.0) : vec4(rotate_outer2(normal, p, ray, separation), 1.0);\n    return color;\n  }\n}\n\nvoid main() {\n  const float gamma = 2.2;\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  float alpha = 0.0;\n  const uint aa_grid_size = 1u;\n  const float aa_sample_width = 1.0 / float(1u + aa_grid_size);\n  const vec2 pixel_origin = vec2(0.5, 0.5);\n  vec2 local_frag_coord = gl_FragCoord.xy - viewport.xy;\n  mat2 rotation = rotation_2d(0.2);\n  for (uint y = 1u; y <= aa_grid_size; ++y) {\n    for (uint x = 1u; x <= aa_grid_size; ++x) {\n      vec2 sample_offset = (aa_sample_width * vec2(float(x), float(y))) - pixel_origin;\n      sample_offset = rotation * sample_offset;\n      sample_offset = fract(sample_offset + pixel_origin) - pixel_origin;\n      {\n        vec2 Frag_Coord = local_frag_coord + sample_offset;\n        vec2 resolution = viewport.zw;\n        vec2 frag_coord = ((Frag_Coord - (0.5 * resolution)) / max_(resolution)) * 2.0;\n        vec4 this_sample = clamp(sample_(camera_type, frag_coord, free_camera_orbit, free_camera_target, free_camera_zoom, separation), 0.0, 1.0);\n        color += this_sample.rgb * this_sample.a;\n        alpha += this_sample.a;\n      }\n    }\n  }\n  if (alpha > 0.0) {\n    color = color / alpha;\n    alpha /= float(aa_grid_size * aa_grid_size);\n  }\n  frag_color = vec4(pow_(color, 1.0 / gamma), alpha);\n}\n",
      freeCamera: true,
      uniforms: {
        separation: "float"
      }
    });
    bauble.setCamera({rotation: [0, 0]});
    let separation = 0;
    let velocity = 0;
    let editing = false;
    let bounce = bounceCheckbox.checked;
    bauble.set({separation});

    const dampen = () => {
      if (!editing && bounce) {
        const oldSeparation = separation;
        separation = separation + velocity;
        const acceleration = -0.05 * separation;
        if (separation < 0) {
          separation *= -1;
          velocity *= -1;
        }
        velocity += acceleration;
        velocity *= 0.9;
        slider.valueAsNumber = separation;
        // only set if it's different enough, so we
        // don't redraw the canvas endlessly
        if (Math.abs(separation - oldSeparation) > 0.01) {
          bauble.set({separation});
        }
      }
      requestAnimationFrame(dampen);
    };
    dampen();

    canvas.addEventListener('dblclick', () => {
      bauble.setCamera({rotation: [0, 0]});
    });

    bounceCheckbox.addEventListener('input', (e) => {
      bounce = bounceCheckbox.checked;
    });

    slider.addEventListener('input', (e) => {
      editing = true;
      separation = slider.valueAsNumber;
      bauble.set({separation});
    });
    slider.addEventListener('change', (e) => {
      editing = false;
      velocity = 0;
    });
  };

  const planetExample = (canvas) => {
    const slider = canvas.nextElementSibling.querySelector('input');
    canvas.width = canvas.clientWidth * 0.25;
    canvas.height = canvas.clientHeight * 0.25;
    const bauble = new Bauble(canvas, {
      source: "#version 300 es\nprecision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\nstruct Light {\n  vec3 color;\n  vec3 direction;\n  float brightness;\n};\n\nout vec4 frag_color;\n\nuniform float cutaway_dist;\nuniform int camera_type;\nuniform vec3 free_camera_target;\nuniform vec2 free_camera_orbit;\nuniform float free_camera_zoom;\nuniform vec2 origin_2d;\nuniform float t;\nuniform vec4 viewport;\n\nmat2 rotation_2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat max_(vec2 v) {\n  return max(v.x, v.y);\n}\n\nmat3 rotation_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 perspective_vector(float fov, vec2 frag_coord) {\n  float cot_half_fov = tan(radians(90.0 - (fov * 0.5)));\n  return normalize(vec3(frag_coord, cot_half_fov));\n}\n\nfloat sdf_sphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\nfloat max_1(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat sdf_cube(float size, vec3 p) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.0)) + min(max_1(d), 0.0);\n}\n\nfloat do_(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  return sdf_cube((cutaway_dist - 3.0) - r, p) - r;\n}\n\nfloat move_outer(float cutaway_dist, vec3 p) {\n  {\n    vec3 p1 = p - (vec3(70.0) * 1.0);\n    return do_(cutaway_dist, p1);\n  }\n}\n\nfloat smooth_min_distance(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  float nearest = sdf_sphere(100.0, p);\n  float dist = -move_outer(cutaway_dist, p);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat do_1(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  return sdf_cube((cutaway_dist - 6.0) - r, p) - r;\n}\n\nfloat move_outer1(float cutaway_dist, vec3 p) {\n  {\n    vec3 p1 = p - (vec3(70.0) * 1.0);\n    return do_1(cutaway_dist, p1);\n  }\n}\n\nfloat smooth_min_distance1(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  float nearest = sdf_sphere(95.0, p);\n  float dist = -move_outer1(cutaway_dist, p);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat do_2(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  return sdf_cube((cutaway_dist - 9.0) - r, p) - r;\n}\n\nfloat move_outer2(float cutaway_dist, vec3 p) {\n  {\n    vec3 p1 = p - (vec3(70.0) * 1.0);\n    return do_2(cutaway_dist, p1);\n  }\n}\n\nfloat smooth_min_distance2(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  float nearest = sdf_sphere(70.0, p);\n  float dist = -move_outer2(cutaway_dist, p);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat smooth_min_distance3(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  float nearest = smooth_min_distance(cutaway_dist, p);\n  float dist = smooth_min_distance1(cutaway_dist, p);\n  float h = (clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5;\n  nearest = mix(nearest, dist, h) - (r * h * (1.0 - h));\n  float dist1 = smooth_min_distance2(cutaway_dist, p);\n  float h1 = (clamp((nearest - dist1) / r, -1.0, 1.0) + 1.0) * 0.5;\n  nearest = mix(nearest, dist1, h1) - (r * h1 * (1.0 - h1));\n  float dist2 = sdf_sphere(50.0, p);\n  float h2 = (clamp((nearest - dist2) / r, -1.0, 1.0) + 1.0) * 0.5;\n  nearest = mix(nearest, dist2, h2) - (r * h2 * (1.0 - h2));\n  return nearest;\n}\n\nvec3 mod289(vec3 x) {\n  return x - (floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod2891(vec4 x) {\n  return x - (floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 permute(vec4 x) {\n  return mod2891(((x * 34.0) + 10.0) * x);\n}\n\nvec4 taylor_inv_sqrt(vec4 r) {\n  return 1.79284291400159 - (0.85373472095314 * r);\n}\n\nvec3 fade(vec3 t) {\n  return t * t * t * ((t * ((t * 6.0) - 15.0)) + 10.0);\n}\n\nfloat perlin(vec3 point) {\n  vec3 Pi0 = floor(point);\n  vec3 Pi1 = Pi0 + 1.0;\n  vec3 Pi01 = mod289(Pi0);\n  vec3 Pi11 = mod289(Pi1);\n  vec3 Pf0 = fract(point);\n  vec3 Pf1 = Pf0 - 1.0;\n  vec4 ix = vec4(Pi01.x, Pi11.x, Pi01.x, Pi11.x);\n  vec4 iy = vec4(Pi01.yy, Pi11.yy);\n  vec4 iz0 = Pi01.zzzz;\n  vec4 iz1 = Pi11.zzzz;\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = 0.5 - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = 0.5 - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n  vec4 norm0 = taylor_inv_sqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylor_inv_sqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat let_outer(vec3 p) {\n  {\n    float from = 1.0;\n    return ((-1.0 - from) * ((sin((6.28318530717959 * p.y) / 2.0) + 1.0) * 0.5)) + from;\n  }\n}\n\nfloat let_outer1(float result) {\n  {\n    float from_start = 0.0;\n    float from_end = 0.01;\n    return (from_start < from_end) ? smoothstep(from_start, from_end, result) : (1.0 - smoothstep(from_end, from_start, result));\n  }\n}\n\nfloat landmasses(vec3 p) {\n  vec3 p1 = normalize(p) * 2.0;\n  float result = perlin(p1) * let_outer(p1);\n  float a = 0.5;\n  for (int i = 0; i < 3; ++i) {\n    if (abs(result) < 0.5) result += perlin(p1) * a;\n    p1 *= 3.0;\n    a *= 0.5;\n  }\n  return let_outer1(result);\n}\n\nfloat expound(float elevation, vec3 p) {\n  float magnitude = 0.5;\n  float threshold = magnitude;\n  float dist = sdf_sphere(100.5, p);\n  float bounding_dist = dist - magnitude;\n  return (bounding_dist < threshold) ? (dist - (elevation * magnitude)) : bounding_dist;\n}\n\nfloat let_outer2(vec3 p) {\n  {\n    float elevation = landmasses(p);\n    vec3 norm = normalize(p);\n    return expound(elevation, p);\n  }\n}\n\nfloat rotate_outer(vec3 p, float t) {\n  {\n    vec3 p1 = p * (rotation_x(degrees(-5.0)) * rotation_y(t / 20.0));\n    return let_outer2(p1);\n  }\n}\n\nfloat do_3(float cutaway_dist, vec3 p) {\n  float r = 1.0;\n  return sdf_cube((cutaway_dist - 0.0) - r, p) - r;\n}\n\nfloat move_outer3(float cutaway_dist, vec3 p) {\n  {\n    vec3 p1 = p - (vec3(70.0) * 1.0);\n    return do_3(cutaway_dist, p1);\n  }\n}\n\nfloat smooth_min_distance4(float cutaway_dist, vec3 p, float t) {\n  float r = 1.0;\n  float nearest = rotate_outer(p, t);\n  float dist = -move_outer3(cutaway_dist, p);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat min_distance(float cutaway_dist, vec3 p, float t) {\n  float nearest = smooth_min_distance3(cutaway_dist, p);\n  nearest = min(nearest, smooth_min_distance4(cutaway_dist, p, t));\n  return nearest;\n}\n\nfloat rotate_outer1(float cutaway_dist, vec3 p, float t) {\n  {\n    vec3 p1 = p * rotation_y(0.392699081698724);\n    return min_distance(cutaway_dist, p1, t);\n  }\n}\n\nfloat nearest_distance(float cutaway_dist, vec3 p, float t) {\n  return rotate_outer1(cutaway_dist, p, t);\n}\n\nfloat march(out uint steps, float cutaway_dist, Ray ray, float t) {\n  float ray_depth = 0.0;\n  for (steps = 0u; steps < 256u; ++steps) {\n    {\n      float depth = ray_depth;\n      vec3 P = ray.origin + (ray_depth * ray.direction);\n      vec3 p = P;\n      float dist = nearest_distance(cutaway_dist, p, t);\n      if (((dist >= 0.0) && (dist < 0.1)) || (ray_depth > 65536.0)) return ray_depth;\n      float rate = (dist > 0.0) ? 0.95 : 1.05;\n      ray_depth += dist * rate;\n      if (ray_depth < 0.0) return 0.0;\n    }\n  }\n  return ray_depth;\n}\n\nfloat with_outer(float cutaway_dist, vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return nearest_distance(cutaway_dist, p1, t);\n  }\n}\n\nfloat with_outer1(float cutaway_dist, vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return nearest_distance(cutaway_dist, p1, t);\n  }\n}\n\nfloat with_outer2(float cutaway_dist, vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return nearest_distance(cutaway_dist, p1, t);\n  }\n}\n\nfloat with_outer3(float cutaway_dist, vec3 p, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return nearest_distance(cutaway_dist, p1, t);\n  }\n}\n\nvec3 normalize_safe(vec3 v) {\n  return (v == vec3(0.0)) ? v : normalize(v);\n}\n\nLight cast_light_no_shadow(vec3 light_color, vec3 light_position, vec3 P) {\n  return Light(light_color, normalize_safe(light_position - P), 1.0);\n}\n\nfloat with_outer4(vec3 P, float cutaway_dist, uint i, vec3 step, float t) {\n  {\n    vec3 P1 = (float(i) * step) + P;\n    vec3 p = P1;\n    return max(nearest_distance(cutaway_dist, p, t), 0.0);\n  }\n}\n\nfloat calculate_occlusion(uint step_count, float max_distance, vec3 dir, vec3 P, float cutaway_dist, vec3 p, float t) {\n  float step_size = max_distance / float(step_count);\n  float baseline = nearest_distance(cutaway_dist, p, t);\n  float occlusion = 0.0;\n  vec3 step = dir * step_size;\n  for (uint i = 1u; i <= step_count; ++i) {\n    float expected_distance = (float(i) * step_size) + baseline;\n    float actual_distance = with_outer4(P, cutaway_dist, i, step, t);\n    occlusion += actual_distance / expected_distance;\n  }\n  return clamp(occlusion / float(step_count), 0.0, 1.0);\n}\n\nLight do_4(vec3 P, vec3 normal, float occlusion) {\n  Light light = cast_light_no_shadow(vec3(1.0), P + normal, P);\n  light.brightness = light.brightness * mix(0.8, 1.0, occlusion);\n  return light;\n}\n\nuint union_color_index(float cutaway_dist, vec3 p, float t) {\n  float nearest = smooth_min_distance4(cutaway_dist, p, t);\n  uint nearest_index = 0u;\n  float d = smooth_min_distance4(cutaway_dist, p, t);\n  if (d < 0.0) return 0u;\n  if (d < nearest) {\n    nearest = d;\n    nearest_index = 0u;\n  }\n  float d1 = smooth_min_distance3(cutaway_dist, p);\n  if (d1 < 0.0) return 1u;\n  if (d1 < nearest) {\n    nearest = d1;\n    nearest_index = 1u;\n  }\n  return nearest_index;\n}\n\nfloat dot_(vec3 v) {\n  return dot(v, v);\n}\n\nfloat simplex(vec3 point) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i = floor(point + dot(point, C.yyy));\n  vec3 x0 = (point - i) + dot(i, C.xxx);\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n  vec3 x1 = (x0 - i1) + C.xxx;\n  vec3 x2 = (x0 - i2) + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod289(i);\n  vec4 p = permute((permute((permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y) + vec4(0.0, i1.y, i2.y, 1.0)) + i.x) + vec4(0.0, i1.x, i2.x, 1.0));\n  const float n_ = 1.0 / 7.0;\n  vec3 ns = (n_ * D.wyz) - D.xzx;\n  vec4 j = p - (floor((p * ns.z) * ns.z) * 49.0);\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - (7.0 * x_));\n  vec4 x = (x_ * ns.x) + ns.yyyy;\n  vec4 y = (y_ * ns.x) + ns.yyyy;\n  vec4 h = (1.0 - abs(x)) - abs(y);\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n  vec4 s0 = (floor(b0) * 2.0) + 1.0;\n  vec4 s1 = (floor(b1) * 2.0) + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = (s0.xzyw * sh.xxyy) + b0.xzyw;\n  vec4 a1 = (s1.xzyw * sh.zzww) + b1.xzyw;\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n  vec4 norm = taylor_inv_sqrt(vec4(dot_(p0), dot_(p1), dot_(p2), dot_(p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.5 - vec4(dot_(x0), dot_(x1), dot_(x2), dot_(x3)), 0.0);\n  m *= m;\n  m *= m;\n  return dot(vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)), m) * 105.0;\n}\n\nfloat with_outer5(vec3 p) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return simplex(p1 / 2.0);\n  }\n}\n\nfloat with_outer6(vec3 p) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return simplex(p1 / 2.0);\n  }\n}\n\nfloat with_outer7(vec3 p) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return simplex(p1 / 2.0);\n  }\n}\n\nfloat with_outer8(vec3 p) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return simplex(p1 / 2.0);\n  }\n}\n\nvec3 hsv(float hue, float saturation, float value) {\n  vec3 c = abs(mod((hue * 6.0) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0);\n  return value * mix(vec3(1.0), clamp(c - 1.0, 0.0, 1.0), saturation);\n}\n\nvec3 blinn_phong(Light light, vec3 color, float shininess, float glossiness, vec3 normal, Ray ray) {\n  if (light.direction == vec3(0.0)) return color * light.color * light.brightness;\n  vec3 halfway_dir = normalize(light.direction - ray.direction);\n  float specular_strength = shininess * pow(max(dot(normal, halfway_dir), 0.0), glossiness * glossiness);\n  float diffuse = max(0.0, dot(normal, light.direction));\n  return ((light.color * light.brightness) * specular_strength) + (color * diffuse * light.color * light.brightness);\n}\n\nvec3 shade(Light light, vec3 normal, Ray ray, vec3 temp, float temp1) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.1, temp1, normal, ray);\n  return result;\n}\n\nvec3 shade_outer(float elevation, Light light, vec3 norm, vec3 normal, Ray ray) {\n  {\n    vec3 temp = mix(mix(hsv(0.66, 1.0, 0.3), mix(mix(hsv(0.333333333333333, 0.8, 0.15), vec3(1.0, 1.0, 1.0), smoothstep(0.6, 1.0, abs(norm.y))), hsv(0.106666666666667, 0.85, 0.5), 1.0 - smoothstep(0.0, 0.25, abs(norm.y))), elevation), vec3(1.0, 1.0, 1.0), smoothstep(1.0, 2.0, elevation) * abs(norm.y));\n    float temp1 = (smoothstep(0.0, 1.0, elevation) * -5.0) + 10.0;\n    return shade(light, normal, ray, temp, temp1);\n  }\n}\n\nvec3 with_outer9(float elevation, Light light, vec3 norm, vec3 normal, vec3 p, Ray ray) {\n  {\n    vec3 normal1 = (elevation == 0.0) ? normalize(((smoothstep(0.0, 0.3, normalize((vec2(1.0, -1.0).xyy * with_outer5(p)) + (vec2(1.0, -1.0).yyx * with_outer6(p)) + (vec2(1.0, -1.0).yxy * with_outer7(p)) + (vec2(1.0, -1.0).xxx * with_outer8(p)))) * 0.11) + -0.1) + normal) : normal;\n    return shade_outer(elevation, light, norm, normal1, ray);\n  }\n}\n\nvec3 let_outer3(Light light, vec3 normal, vec3 p, Ray ray) {\n  {\n    float elevation = landmasses(p);\n    vec3 norm = normalize(p);\n    return with_outer9(elevation, light, norm, normal, p, ray);\n  }\n}\n\nvec3 rotate_outer2(Light light, vec3 normal, vec3 p, Ray ray, float t) {\n  {\n    vec3 p1 = p * (rotation_x(degrees(-5.0)) * rotation_y(t / 20.0));\n    return let_outer3(light, normal, p1, ray);\n  }\n}\n\nfloat fresnel(float exponent, vec3 normal, Ray ray) {\n  return pow(1.0 + dot(normal, ray.direction), exponent);\n}\n\nvec3 map_color(Light light, vec3 normal, vec3 p, Ray ray, float t) {\n  vec3 color = rotate_outer2(light, normal, p, ray, t);\n  return color + (hsv(0.583333333333333, 0.98, 1.0) * (fresnel(4.0, normal, ray) * 0.2));\n}\n\nuint union_color_index1(float cutaway_dist, vec3 p) {\n  float nearest = sdf_sphere(50.0, p);\n  uint nearest_index = 0u;\n  float d = sdf_sphere(50.0, p);\n  if (d < 0.0) return 0u;\n  if (d < nearest) {\n    nearest = d;\n    nearest_index = 0u;\n  }\n  float d1 = smooth_min_distance2(cutaway_dist, p);\n  if (d1 < 0.0) return 1u;\n  if (d1 < nearest) {\n    nearest = d1;\n    nearest_index = 1u;\n  }\n  float d2 = smooth_min_distance1(cutaway_dist, p);\n  if (d2 < 0.0) return 2u;\n  if (d2 < nearest) {\n    nearest = d2;\n    nearest_index = 2u;\n  }\n  float d3 = smooth_min_distance(cutaway_dist, p);\n  if (d3 < 0.0) return 3u;\n  if (d3 < nearest) {\n    nearest = d3;\n    nearest_index = 3u;\n  }\n  return nearest_index;\n}\n\nvec3 shade1(Light light, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer1(Light light, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.166666666666667, 0.98, 1.0);\n    return shade1(light, normal, ray, temp);\n  }\n}\n\nvec3 shade2(Light light, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer2(Light light, vec3 normal, vec3 p, Ray ray, float t) {\n  {\n    vec3 temp = mix(hsv(0.0833333333333333, 0.98, 1.0), hsv(0.166666666666667, 0.98, 1.0), simplex(((t * 20.0) - p) / 40.0));\n    return shade2(light, normal, ray, temp);\n  }\n}\n\nvec3 shade3(Light light, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer3(Light light, vec3 normal, vec3 p, Ray ray, float t) {\n  {\n    vec3 temp = mix(hsv(0.0, 0.98, 1.0), hsv(0.0833333333333333, 0.98, 1.0), simplex(((t * 20.0) - p) / 40.0));\n    return shade3(light, normal, ray, temp);\n  }\n}\n\nvec3 shade4(Light light, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer4(Light light, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.03, 1.0, 0.25);\n    return shade4(light, normal, ray, temp);\n  }\n}\n\nvec3 union_color(float cutaway_dist, Light light, vec3 normal, vec3 p, Ray ray, float t) {\n  switch (union_color_index1(cutaway_dist, p)) {\n  case 0u: return shade_outer1(light, normal, ray);\n  case 1u: return shade_outer2(light, normal, p, ray, t);\n  case 2u: return shade_outer3(light, normal, p, ray, t);\n  case 3u: return shade_outer4(light, normal, ray);\n  }\n  return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 union_color1(float cutaway_dist, Light light, Light light1, vec3 normal, vec3 p, Ray ray, float t) {\n  switch (union_color_index(cutaway_dist, p, t)) {\n  case 0u: return map_color(light, normal, p, ray, t);\n  case 1u: return union_color(cutaway_dist, light1, normal, p, ray, t);\n  }\n  return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 rotate_outer3(float cutaway_dist, Light light, Light light1, vec3 normal, vec3 p, Ray ray, float t) {\n  {\n    vec3 p1 = p * rotation_y(0.392699081698724);\n    return union_color1(cutaway_dist, light, light1, normal, p1, ray, t);\n  }\n}\n\nfloat sum(vec2 v) {\n  return v.x + v.y;\n}\n\nvec3 pow_(vec3 v, float e) {\n  return pow(v, vec3(e));\n}\n\nvec3 let_outer4(vec3 color) {\n  {\n    float dollar_count = 8.0;\n    return round(pow_(color, 0.454545454545455) * dollar_count) / dollar_count;\n  }\n}\n\nvec3 map_color1(vec2 Frag_Coord, float cutaway_dist, Light light, Light light1, vec3 normal, vec3 p, Ray ray, float t) {\n  vec3 color = rotate_outer3(cutaway_dist, light1, light, normal, p, ray, t);\n  return (mod(sum(floor(Frag_Coord)), 2.0) == 0.0) ? pow_(let_outer4(color), 2.2) : color;\n}\n\nvec3 hoist_outer(vec2 Frag_Coord, vec3 P, float cutaway_dist, vec3 normal, vec3 p, Ray ray, float t) {\n  {\n    Light light = cast_light_no_shadow(vec3(2.0), P - (vec3(1.0, -1.0, -4.0) * 100.0), P);\n    float occlusion = calculate_occlusion(8u, 20.0, normal, P, cutaway_dist, p, t);\n    Light light1 = do_4(P, normal, occlusion);\n    return map_color1(Frag_Coord, cutaway_dist, light1, light, normal, p, ray, t);\n  }\n}\n\nvec4 sample_(vec2 Frag_Coord, int camera_type, float cutaway_dist, vec2 frag_coord, vec2 free_camera_orbit, vec3 free_camera_target, float free_camera_zoom, float t) {\n  Ray ray_star = Ray(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n  vec3 ortho_quad = vec3(1024.0, (frag_coord * 212.077343935025) * free_camera_zoom);\n  float ortho_scale = 212.077343935025 * free_camera_zoom;\n  float fov = 0.0;\n  switch (camera_type) {\n  case 0: case 1: {\n    mat3 camera_rotation_matrix = rotation_y(6.28318530717959 * free_camera_orbit.x) * rotation_x(6.28318530717959 * free_camera_orbit.y);\n    ray_star = Ray((camera_rotation_matrix * vec3(0.0, 0.0, 512.0 * free_camera_zoom)) + free_camera_target, camera_rotation_matrix * (perspective_vector(45.0, frag_coord) * vec3(1.0, 1.0, -1.0)));\n    fov = 45.0;\n    break;\n  }\n  case 2: {\n    ray_star = Ray(ortho_quad.yxz + free_camera_target, vec3(0.0, -1.0, 0.0));\n    break;\n  }\n  case 3: {\n    ray_star = Ray(ortho_quad.yzx + free_camera_target, vec3(0.0, 0.0, -1.0));\n    break;\n  }\n  case 4: {\n    ray_star = Ray(ortho_quad.xzy + free_camera_target, vec3(-1.0, 0.0, 0.0));\n    break;\n  }\n  }\n  uint steps = 0u;\n  {\n    Ray ray = ray_star;\n    float depth = march(steps, cutaway_dist, ray, t);\n    vec3 P = ray.origin + (ray.direction * depth);\n    vec3 p = P;\n    float dist = nearest_distance(cutaway_dist, p, t);\n    vec3 normal = normalize((vec2(1.0, -1.0).xyy * with_outer(cutaway_dist, p, t)) + (vec2(1.0, -1.0).yyx * with_outer1(cutaway_dist, p, t)) + (vec2(1.0, -1.0).yxy * with_outer2(cutaway_dist, p, t)) + (vec2(1.0, -1.0).xxx * with_outer3(cutaway_dist, p, t)));\n    vec4 color = vec4(0.0);\n    color = (dist >= 10.0) ? vec4(0.0) : vec4(hoist_outer(Frag_Coord, P, cutaway_dist, normal, p, ray, t), 1.0);\n    return color;\n  }\n}\n\nvoid main() {\n  const float gamma = 2.2;\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  float alpha = 0.0;\n  const uint aa_grid_size = 2u;\n  const float aa_sample_width = 1.0 / float(1u + aa_grid_size);\n  const vec2 pixel_origin = vec2(0.5, 0.5);\n  vec2 local_frag_coord = gl_FragCoord.xy - viewport.xy;\n  mat2 rotation = rotation_2d(0.2);\n  for (uint y = 1u; y <= aa_grid_size; ++y) {\n    for (uint x = 1u; x <= aa_grid_size; ++x) {\n      vec2 sample_offset = (aa_sample_width * vec2(float(x), float(y))) - pixel_origin;\n      sample_offset = rotation * sample_offset;\n      sample_offset = fract(sample_offset + pixel_origin) - pixel_origin;\n      {\n        vec2 Frag_Coord = local_frag_coord + sample_offset;\n        vec2 resolution = viewport.zw;\n        vec2 frag_coord = ((Frag_Coord - (0.5 * resolution)) / max_(resolution)) * 2.0;\n        vec4 this_sample = clamp(sample_(Frag_Coord, camera_type, cutaway_dist, frag_coord, free_camera_orbit, free_camera_target, free_camera_zoom, t), 0.0, 1.0);\n        color += this_sample.rgb * this_sample.a;\n        alpha += this_sample.a;\n      }\n    }\n  }\n  if (alpha > 0.0) {\n    color = color / alpha;\n    alpha /= float(aa_grid_size * aa_grid_size);\n  }\n  frag_color = vec4(pow_(color, 1.0 / gamma), alpha);\n}\n",
      animate: true,
      freeCamera: true,
      uniforms: {
        cutaway_dist: "float"
      }
    });
    bauble.setCamera({zoom: 0.53});
    let cutaway_dist = 0;
    bauble.set({cutaway_dist});
    slider.addEventListener('input', (e) => {
      cutaway_dist = slider.valueAsNumber;
      if (cutaway_dist === 100) {
        const container = document.createElement('div');
        container.innerHTML = '<span style="position: absolute; color: black; transition: opacity 1s linear, top 1s ease-out, left 1s ease-out, transform 1s ease-out;">wow</span>';
        const wow = container.firstElementChild;
        wow.addEventListener('transitionend', () => {
          wow.parentElement.removeChild(wow);
        });
        canvas.parentElement.appendChild(wow);
        const center = [
          (canvas.offsetLeft + 0.5 * canvas.offsetWidth),
          (canvas.offsetTop + 0.5 * canvas.offsetHeight),
        ];
        wow.style.left = (center[0] - 0.5 * wow.offsetWidth).toString() + 'px';
        wow.style.top = (center[1] - 0.5 * wow.offsetHeight).toString() + 'px';
        wow.style.opacity = '0';

        center[0] += Math.random() * 20 - 10;
        center[1] += Math.random() * -10 - 10;

        wow.style.left = (center[0] - 0.5 * wow.offsetWidth).toString() + 'px';
        wow.style.top = (center[1] - 0.5 * wow.offsetHeight).toString() + 'px';
        wow.style.transform = \`rotate(\${Math.random() * 60 - 30}deg)\`;
      }
      bauble.set({cutaway_dist});
    });
    return bauble.togglePlay;
  };

  const gameExample = (canvas) => {
    canvas.width = canvas.clientWidth * 0.25;
    canvas.height = canvas.clientHeight * 0.25;
    const bauble = new Bauble(canvas, {
      source: "#version 300 es\nprecision highp float;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\nstruct OrthographicCamera {\n  vec3 position;\n  vec3 direction;\n  vec3 up;\n  float scale;\n};\nstruct Light {\n  vec3 color;\n  vec3 direction;\n  float brightness;\n};\n\nout vec4 frag_color;\n\nuniform vec3 player_pos;\nuniform vec3 light_target;\nuniform int camera_type;\nuniform vec3 free_camera_target;\nuniform vec2 free_camera_orbit;\nuniform float free_camera_zoom;\nuniform vec2 origin_2d;\nuniform float t;\nuniform vec4 viewport;\n\nmat2 rotation_2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat max_(vec2 v) {\n  return max(v.x, v.y);\n}\n\nRay let_outer(OrthographicCamera camera, vec2 frag_coord, vec3 x_axis, vec3 y_axis, vec3 z_axis) {\n  {\n    mat3 rotation_matrix = mat3(x_axis, y_axis, z_axis);\n    return Ray(((rotation_matrix * vec3(frag_coord, 0.0)) * camera.scale) + camera.position, rotation_matrix * vec3(0.0, 0.0, 1.0));\n  }\n}\n\nRay let_outer1(OrthographicCamera camera, vec2 frag_coord) {\n  {\n    OrthographicCamera camera1 = camera;\n    vec3 z_axis = camera1.direction;\n    vec3 x_axis = normalize(cross(z_axis, camera1.up));\n    vec3 y_axis = cross(x_axis, z_axis);\n    return let_outer(camera1, frag_coord, x_axis, y_axis, z_axis);\n  }\n}\n\nmat3 rotation_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotation_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n}\n\nvec3 perspective_vector(float fov, vec2 frag_coord) {\n  float cot_half_fov = tan(radians(90.0 - (fov * 0.5)));\n  return normalize(vec3(frag_coord, cot_half_fov));\n}\n\nfloat max_1(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat sdf_box(vec3 size, vec3 p) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.0)) + min(max_1(d), 0.0);\n}\n\nfloat do_(vec3 p) {\n  float r = 10.0;\n  return sdf_box(vec3(100.0, 10.0, 100.0) - r, p) - r;\n}\n\nvec3 mod289(vec3 x) {\n  return x - (floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 mod2891(vec4 x) {\n  return x - (floor(x * (1.0 / 289.0)) * 289.0);\n}\n\nvec4 permute(vec4 x) {\n  return mod2891(((x * 34.0) + 10.0) * x);\n}\n\nvec4 taylor_inv_sqrt(vec4 r) {\n  return 1.79284291400159 - (0.85373472095314 * r);\n}\n\nfloat dot_(vec3 v) {\n  return dot(v, v);\n}\n\nfloat simplex(vec3 point) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i = floor(point + dot(point, C.yyy));\n  vec3 x0 = (point - i) + dot(i, C.xxx);\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n  vec3 x1 = (x0 - i1) + C.xxx;\n  vec3 x2 = (x0 - i2) + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod289(i);\n  vec4 p = permute((permute((permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y) + vec4(0.0, i1.y, i2.y, 1.0)) + i.x) + vec4(0.0, i1.x, i2.x, 1.0));\n  const float n_ = 1.0 / 7.0;\n  vec3 ns = (n_ * D.wyz) - D.xzx;\n  vec4 j = p - (floor((p * ns.z) * ns.z) * 49.0);\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - (7.0 * x_));\n  vec4 x = (x_ * ns.x) + ns.yyyy;\n  vec4 y = (y_ * ns.x) + ns.yyyy;\n  vec4 h = (1.0 - abs(x)) - abs(y);\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n  vec4 s0 = (floor(b0) * 2.0) + 1.0;\n  vec4 s1 = (floor(b1) * 2.0) + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = (s0.xzyw * sh.xxyy) + b0.xzyw;\n  vec4 a1 = (s1.xzyw * sh.zzww) + b1.xzyw;\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n  vec4 norm = taylor_inv_sqrt(vec4(dot_(p0), dot_(p1), dot_(p2), dot_(p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.5 - vec4(dot_(x0), dot_(x1), dot_(x2), dot_(x3)), 0.0);\n  m *= m;\n  m *= m;\n  return dot(vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)), m) * 105.0;\n}\n\nfloat expound(vec3 p) {\n  float magnitude = 0.3;\n  float threshold = magnitude;\n  float dist = do_(p);\n  float bounding_dist = dist - magnitude;\n  return (bounding_dist < threshold) ? (dist - (pow(simplex(p / 3.0), 2.0) * magnitude)) : bounding_dist;\n}\n\nfloat sdf_symmetric_rect(vec2 size, vec2 q) {\n  vec2 d = abs(q) - size;\n  return length(max(d, 0.0)) + min(max_(d), 0.0);\n}\n\nfloat do_1(vec2 q) {\n  float r = 20.0;\n  return sdf_symmetric_rect(vec2(100.0 - r), q) - r;\n}\n\nfloat extrude_outer(vec3 p) {\n  {\n    vec2 q = p.xz;\n    return abs(do_1(q)) - (10.0 * 0.5);\n  }\n}\n\nfloat extrude(vec3 p) {\n  vec2 w = vec2(extrude_outer(p), abs(p.y) - 30.0);\n  return min(max_(w), 0.0) + length(max(w, 0.0));\n}\n\nvec3 safe_div(vec3 a, vec3 b) {\n  return vec3((b.x == 0.0) ? 0.0 : (a.x / b.x), (b.y == 0.0) ? 0.0 : (a.y / b.y), (b.z == 0.0) ? 0.0 : (a.z / b.z));\n}\n\nfloat with_outer(vec3 p, vec3 size) {\n  {\n    vec3 tile_index = round(safe_div(p, size));\n    vec3 p1 = p - (size * tile_index);\n    return sdf_box(vec3(3.0, 1.5, 2.0), p1);\n  }\n}\n\nfloat let_outer2(vec3 p) {\n  {\n    vec3 size = vec3(6.0, 3.0, 4.0);\n    return with_outer(p, size);\n  }\n}\n\nfloat smooth_min_distance(vec3 p) {\n  float r = 1.0;\n  float nearest = extrude(p);\n  float dist = let_outer2(p);\n  float h = 1.0 - ((clamp((nearest - dist) / r, -1.0, 1.0) + 1.0) * 0.5);\n  nearest = mix(nearest, dist, h) + (r * h * (1.0 - h));\n  return nearest;\n}\n\nfloat min_distance(vec3 p) {\n  float nearest = expound(p);\n  nearest = min(nearest, smooth_min_distance(p));\n  return nearest;\n}\n\nfloat move_outer(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * -10.0);\n    return min_distance(p1);\n  }\n}\n\nfloat sdf_circle(float radius, vec2 q) {\n  return length(q) - radius;\n}\n\nfloat extrude_outer1(vec3 p) {\n  {\n    vec2 q = p.xz;\n    return abs(sdf_circle(5.0, q)) - (2.0 * 0.5);\n  }\n}\n\nfloat extrude1(vec3 p) {\n  vec2 w = vec2(extrude_outer1(p), abs(p.y) - 2.0);\n  return min(max_(w), 0.0) + length(max(w, 0.0));\n}\n\nfloat dot_1(vec2 v) {\n  return dot(v, v);\n}\n\nfloat sdf_round_cone_y(float radius, float height, float round, vec3 p) {\n  vec2 other_axes = p.xz;\n  float this_axis = p.y;\n  float offset = (height / radius) * round;\n  radius -= round;\n  height -= offset;\n  vec2 q = vec2(radius, -height);\n  vec2 w = vec2(length(other_axes), (this_axis - height) - (sign(height) * round));\n  vec2 a = w - (q * clamp(dot(w, q) / dot_1(q), 0.0, 1.0));\n  vec2 b = w - (q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0));\n  float k = sign(q.y);\n  float d = min(dot_1(a), dot_1(b));\n  float s = max(k * ((w.x * q.y) - (w.y * q.x)), k * (w.y - q.y));\n  return (sqrt(d) * sign(s)) - round;\n}\n\nmat3 alignment_matrix(vec3 from, vec3 to) {\n  vec3 axis = cross(to, from);\n  float cosA = dot(to, from);\n  float k = 1.0 / (1.0 + cosA);\n  return mat3(((axis.x * axis.x) * k) + cosA, ((axis.y * axis.x) * k) - axis.z, ((axis.z * axis.x) * k) + axis.y, ((axis.x * axis.y) * k) + axis.z, ((axis.y * axis.y) * k) + cosA, ((axis.z * axis.y) * k) - axis.x, ((axis.x * axis.z) * k) - axis.y, ((axis.y * axis.z) * k) + axis.x, ((axis.z * axis.z) * k) + cosA);\n}\n\nfloat sdf_ellipsoid(vec3 size, vec3 p) {\n  float k0 = length(p / size);\n  float k1 = length(p / (size * size));\n  return (k0 * (k0 - 1.0)) / k1;\n}\n\nfloat min_distance1(vec3 p) {\n  float nearest = sdf_round_cone_y(3.0, -6.0, 0.5, p);\n  nearest = min(nearest, sdf_ellipsoid(vec3(2.0, 1.0, 2.0), p));\n  return nearest;\n}\n\nfloat move_outer1(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 3.0);\n    return min_distance1(p1);\n  }\n}\n\nfloat align_outer(vec3 light_dir, vec3 p) {\n  {\n    vec3 p1 = alignment_matrix(light_dir, vec3(0.0, 1.0, 0.0)) * p;\n    return move_outer1(p1);\n  }\n}\n\nfloat move_outer2(vec3 light_dir, vec3 p) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 10.0);\n    return align_outer(light_dir, p1);\n  }\n}\n\nfloat min_distance2(vec3 light_dir, vec3 p) {\n  float nearest = sdf_round_cone_y(3.0, 10.0, 1.5, p);\n  nearest = min(nearest, move_outer2(light_dir, p));\n  return nearest;\n}\n\nfloat move_outer3(vec3 light_dir, vec3 p, vec3 player_pos) {\n  {\n    vec3 p1 = p - (player_pos * 1.0);\n    return min_distance2(light_dir, p1);\n  }\n}\n\nfloat sdf_cone_y(float radius, float height, vec3 p) {\n  vec2 other_axes = p.xz;\n  float this_axis = p.y;\n  vec2 q = vec2(radius, -height);\n  vec2 w = vec2(length(other_axes), this_axis - height);\n  vec2 a = w - (q * clamp(dot(w, q) / dot_1(q), 0.0, 1.0));\n  vec2 b = w - (q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0));\n  float k = sign(q.y);\n  float d = min(dot_1(a), dot_1(b));\n  float s = max(k * ((w.x * q.y) - (w.y * q.x)), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat fbm(vec3 p, float t) {\n  int octaves = int(3.0);\n  vec3 point = ((vec3(0.0, t, 0.0) * 20.0) - p) / vec3(5.0, 10.0, 5.0);\n  float gain = 0.5;\n  float f = 2.5;\n  float amplitude = 1.0;\n  float result = 0.0;\n  for (int i = 0; i < octaves; ++i) {\n    result += amplitude * simplex(point);\n    point = point * f;\n    amplitude *= gain;\n  }\n  return result;\n}\n\nfloat expound1(vec3 p, float t) {\n  float magnitude = 3.0;\n  float threshold = 19.0;\n  float dist = sdf_cone_y(2.0, 10.0, p);\n  float bounding_dist = dist - magnitude;\n  return (bounding_dist < threshold) ? (dist - (fbm(p, t) * magnitude)) : bounding_dist;\n}\n\nfloat sdf_sphere(float radius, vec3 p) {\n  return length(p) - radius;\n}\n\nfloat move_outer4(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(50.0, 5.0, -50.0) * 1.0);\n    return sdf_sphere(10.0, p1);\n  }\n}\n\nfloat expound2(vec3 p, float t) {\n  float magnitude = (5.0 * (1.0 - ((cos((6.28318530717959 * t) / 3.0) + 1.0) * 0.5))) + 0.0;\n  float threshold = 5.0;\n  float dist = move_outer4(p);\n  float bounding_dist = dist - magnitude;\n  return (bounding_dist < threshold) ? (dist - (simplex((p + (floor(t / 3.0) * 1000.0)) / 10.0) * magnitude)) : bounding_dist;\n}\n\nmat3 rotation_z(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat sdf_box_frame(vec3 size, float thickness, vec3 p) {\n  vec3 p1 = abs(p) - size;\n  vec3 q = abs(p1 + thickness) - thickness;\n  return min(min(length(max(vec3(p1.x, q.y, q.z), 0.0)) + min(max(p1.x, max(q.y, q.z)), 0.0), length(max(vec3(q.x, p1.y, q.z), 0.0)) + min(max(q.x, max(p1.y, q.z)), 0.0)), length(max(vec3(q.x, q.y, p1.z), 0.0)) + min(max(q.x, max(q.y, p1.z)), 0.0));\n}\n\nfloat do_2(vec3 p) {\n  float r = 0.5;\n  return sdf_box_frame(vec3(10.0 - r), 1.0 - r, p) - r;\n}\n\nfloat rotate_outer(vec3 p) {\n  {\n    vec3 p1 = p * (rotation_z(0.4) * rotation_x(0.1));\n    return do_2(p1);\n  }\n}\n\nfloat move_outer5(vec3 p) {\n  {\n    vec3 p1 = p - (vec3(-50.0, 10.0, 50.0) * 1.0);\n    return rotate_outer(p1);\n  }\n}\n\nfloat sdf_octahedron(float radius, vec3 p) {\n  vec3 p1 = abs(p);\n  float m = ((p1.x + p1.y) + p1.z) - radius;\n  vec3 q = vec3(0.0, 0.0, 0.0);\n  if ((3.0 * p1.x) < m) q = p1.xyz;\n  else if ((3.0 * p1.y) < m) q = p1.yzx;\n  else if ((3.0 * p1.z) < m) q = p1.zxy;\n  else return m * (sqrt(3.0) / 3.0);\n  float k = clamp(((q.z - q.y) + radius) * 0.5, 0.0, radius);\n  return length(vec3(q.x, (q.y - radius) + k, q.z - k));\n}\n\nfloat do_3(vec3 p) {\n  float r = 0.5;\n  return sdf_octahedron(15.0 - r, p) - r;\n}\n\nfloat rotate_outer1(vec3 p, float t) {\n  {\n    vec3 p1 = p * rotation_y(t / 4.0);\n    return do_3(p1);\n  }\n}\n\nfloat move_outer6(vec3 p, float t) {\n  {\n    vec3 p1 = p - (vec3(-50.0, (15.0 * (1.0 - ((cos((6.28318530717959 * t) / 8.0) + 1.0) * 0.5))) + 5.0, -50.0) * 1.0);\n    return rotate_outer1(p1, t);\n  }\n}\n\nfloat min_distance3(vec3 light_dir, vec3 p, vec3 player_pos, float t) {\n  float nearest = move_outer(p);\n  nearest = min(nearest, extrude1(p));\n  nearest = min(nearest, move_outer3(light_dir, p, player_pos));\n  nearest = min(nearest, expound1(p, t) * 0.4);\n  nearest = min(nearest, expound2(p, t));\n  nearest = min(nearest, move_outer5(p));\n  nearest = min(nearest, move_outer6(p, t));\n  return nearest;\n}\n\nfloat hoist_outer(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  {\n    vec3 light_dir = normalize(light_target - (vec3(0.0, 8.0, 0.0) + player_pos));\n    return min_distance3(light_dir, p, player_pos, t);\n  }\n}\n\nfloat nearest_distance(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  return hoist_outer(light_target, p, player_pos, t);\n}\n\nfloat march(out uint steps, vec3 light_target, vec3 player_pos, Ray ray, float t) {\n  float ray_depth = 0.0;\n  for (steps = 0u; steps < 256u; ++steps) {\n    {\n      float depth = ray_depth;\n      vec3 P = ray.origin + (ray_depth * ray.direction);\n      vec3 p = P;\n      float dist = nearest_distance(light_target, p, player_pos, t);\n      if (((dist >= 0.0) && (dist < 0.1)) || (ray_depth > 65536.0)) return ray_depth;\n      float rate = (dist > 0.0) ? 0.95 : 1.05;\n      ray_depth += dist * rate;\n      if (ray_depth < 0.0) return 0.0;\n    }\n  }\n  return ray_depth;\n}\n\nfloat with_outer1(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xyy * 0.005) + p;\n    return nearest_distance(light_target, p1, player_pos, t);\n  }\n}\n\nfloat with_outer2(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yyx * 0.005) + p;\n    return nearest_distance(light_target, p1, player_pos, t);\n  }\n}\n\nfloat with_outer3(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).yxy * 0.005) + p;\n    return nearest_distance(light_target, p1, player_pos, t);\n  }\n}\n\nfloat with_outer4(vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  {\n    vec3 p1 = (vec2(1.0, -1.0).xxx * 0.005) + p;\n    return nearest_distance(light_target, p1, player_pos, t);\n  }\n}\n\nvec3 do_4(vec2 Frag_Coord, vec2 resolution) {\n  const vec3 light = pow(vec3(69.0, 72.0, 79.0) / 255.0, vec3(2.2));\n  const vec3 dark = pow(vec3(40.0, 42.0, 46.0) / 255.0, vec3(2.2));\n  return vec3(mix(dark, light, (Frag_Coord.x + Frag_Coord.y) / (resolution.x + resolution.y)));\n}\n\nfloat with_outer5(vec3 P, uint i, vec3 light_target, vec3 player_pos, vec3 step, float t) {\n  {\n    vec3 P1 = (float(i) * step) + P;\n    vec3 p = P1;\n    return max(nearest_distance(light_target, p, player_pos, t), 0.0);\n  }\n}\n\nfloat calculate_occlusion(uint step_count, float max_distance, vec3 dir, vec3 P, vec3 light_target, vec3 p, vec3 player_pos, float t) {\n  float step_size = max_distance / float(step_count);\n  float baseline = nearest_distance(light_target, p, player_pos, t);\n  float occlusion = 0.0;\n  vec3 step = dir * step_size;\n  for (uint i = 1u; i <= step_count; ++i) {\n    float expected_distance = (float(i) * step_size) + baseline;\n    float actual_distance = with_outer5(P, i, light_target, player_pos, step, t);\n    occlusion += actual_distance / expected_distance;\n  }\n  return clamp(occlusion / float(step_count), 0.0, 1.0);\n}\n\nfloat with_outer6(float depth, vec3 light_position, vec3 light_target, vec3 player_pos, vec3 ray_dir, float t) {\n  {\n    vec3 P = light_position + (ray_dir * depth);\n    vec3 p = P;\n    return nearest_distance(light_target, p, player_pos, t);\n  }\n}\n\nLight cast_light_hard_shadow(vec3 light_color, vec3 light_position, vec3 P, vec3 light_target, vec3 normal, vec3 player_pos, float t) {\n  if (light_position == P) return Light(light_color, vec3(0.0), 1.0);\n  vec3 to_light = normalize(light_position - P);\n  if (light_color == vec3(0.0)) return Light(light_color, to_light, 0.0);\n  if (dot(to_light, normal) < 0.0) return Light(light_color, to_light, 0.0);\n  vec3 target = (0.01 * normal) + P;\n  float light_distance = length(target - light_position);\n  vec3 ray_dir = (target - light_position) / light_distance;\n  float depth = 0.0;\n  for (uint i = 0u; i < 256u; ++i) {\n    float nearest = with_outer6(depth, light_position, light_target, player_pos, ray_dir, t);\n    if (nearest < 0.01) break;\n    depth += nearest;\n  }\n  if (depth >= light_distance) return Light(light_color, to_light, 1.0);\n  else return Light(light_color, to_light, 0.0);\n}\n\nfloat with_outer7(float depth, vec3 light_position, vec3 light_target, vec3 player_pos, vec3 ray_dir, float t) {\n  {\n    vec3 P = light_position + (ray_dir * depth);\n    vec3 p = P;\n    return nearest_distance(light_target, p, player_pos, t);\n  }\n}\n\nLight cast_light_soft_shadow(vec3 light_color, vec3 light_position, float softness, vec3 P, vec3 light_target, vec3 normal, vec3 player_pos, float t) {\n  if (softness == 0.0) return cast_light_hard_shadow(light_color, light_position, P, light_target, normal, player_pos, t);\n  if (light_position == P) return Light(light_color, vec3(0.0), 1.0);\n  vec3 to_light = normalize(light_position - P);\n  if (light_color == vec3(0.0)) return Light(light_color, to_light, 0.0);\n  if (dot(to_light, normal) < 0.0) return Light(light_color, to_light, 0.0);\n  vec3 target = (0.01 * normal) + P;\n  float light_distance = length(target - light_position);\n  vec3 ray_dir = (target - light_position) / light_distance;\n  float brightness = 1.0;\n  float sharpness = 1.0 / (softness * softness);\n  float last_nearest = 1000000.0;\n  float depth = 0.0;\n  for (uint i = 0u; i < 256u; ++i) {\n    float nearest = with_outer7(depth, light_position, light_target, player_pos, ray_dir, t);\n    if (nearest < 0.01) break;\n    float intersect_offset = (nearest * nearest) / (2.0 * last_nearest);\n    float intersect_distance = sqrt((nearest * nearest) - (intersect_offset * intersect_offset));\n    brightness = min(brightness, (sharpness * intersect_distance) / max(0.0, (light_distance - depth) - intersect_offset));\n    depth += nearest;\n    last_nearest = nearest;\n  }\n  if (depth >= light_distance) return Light(light_color, to_light, brightness);\n  else return Light(light_color, to_light, 0.0);\n}\n\nvec3 hsv(float hue, float saturation, float value) {\n  vec3 c = abs(mod((hue * 6.0) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0);\n  return value * mix(vec3(1.0), clamp(c - 1.0, 0.0, 1.0), saturation);\n}\n\nfloat atan2(float y, float x) {\n  return (x == 0.0) ? ((0.5 * 3.14159265358979) * sign(y)) : atan(y, x);\n}\n\nfloat atan21(vec2 p) {\n  return atan2(p.y, p.x);\n}\n\nLight do_5(vec3 P, vec3 light_target, vec3 normal, float occlusion, vec3 p, vec3 player_pos, float t) {\n  Light light = cast_light_soft_shadow(mix(hsv(0.07, 1.0, 1.0), hsv(0.05, 1.0, 1.0), ((1.0 * (1.0 - ((cos((6.28318530717959 * t) / 0.732) + 1.0) * 0.5))) + 0.0) * ((1.0 * ((sin((6.28318530717959 * t) / 0.412) + 1.0) * 0.5)) + 0.0)), vec3(0.0, 30.0, 0.0), 0.25, P, light_target, normal, player_pos, t);\n  light.brightness = light.brightness * (((900.0 / pow(distance(vec3(0.0, 30.0, 0.0), P), 2.0)) * occlusion) * mix(1.0, 0.5, ((simplex(vec3(t, length(p.xz), atan21(p.xz)) / vec3(0.7, 20.0, 0.4)) + 1.0) * 0.5) * ((smoothstep(0.0, 100.0, length(p.xz)) * -1.0) + 1.0)));\n  return light;\n}\n\nLight do_6(vec3 P, vec3 flashlight, vec3 flashlight_color, vec3 light_dir, vec3 light_target, vec3 normal, vec3 player_pos, float t) {\n  Light light = cast_light_soft_shadow(flashlight_color, flashlight, 0.1, P, light_target, normal, player_pos, t);\n  light.brightness = light.brightness * pow(smoothstep(0.8, 1.0, dot(light_dir, normalize(P - flashlight))), 3.0);\n  return light;\n}\n\nuint union_color_index(vec3 light_dir, vec3 p, vec3 player_pos, float t) {\n  float nearest = move_outer6(p, t);\n  uint nearest_index = 0u;\n  float d = move_outer6(p, t);\n  if (d < 0.0) return 0u;\n  if (d < nearest) {\n    nearest = d;\n    nearest_index = 0u;\n  }\n  float d1 = move_outer5(p);\n  if (d1 < 0.0) return 1u;\n  if (d1 < nearest) {\n    nearest = d1;\n    nearest_index = 1u;\n  }\n  float d2 = expound2(p, t);\n  if (d2 < 0.0) return 2u;\n  if (d2 < nearest) {\n    nearest = d2;\n    nearest_index = 2u;\n  }\n  float d3 = expound1(p, t) * 0.4;\n  if (d3 < 0.0) return 3u;\n  if (d3 < nearest) {\n    nearest = d3;\n    nearest_index = 3u;\n  }\n  float d4 = move_outer3(light_dir, p, player_pos);\n  if (d4 < 0.0) return 4u;\n  if (d4 < nearest) {\n    nearest = d4;\n    nearest_index = 4u;\n  }\n  float d5 = move_outer(p);\n  if (d5 < 0.0) return 5u;\n  if (d5 < nearest) {\n    nearest = d5;\n    nearest_index = 5u;\n  }\n  return nearest_index;\n}\n\nvec3 blinn_phong(Light light, vec3 color, float shininess, float glossiness, vec3 normal, Ray ray) {\n  if (light.direction == vec3(0.0)) return color * light.color * light.brightness;\n  vec3 halfway_dir = normalize(light.direction - ray.direction);\n  float specular_strength = shininess * pow(max(dot(normal, halfway_dir), 0.0), glossiness * glossiness);\n  float diffuse = max(0.0, dot(normal, light.direction));\n  return ((light.color * light.brightness) * specular_strength) + (color * diffuse * light.color * light.brightness);\n}\n\nvec3 shade(Light light, Light light1, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.583333333333333, 0.98, 1.0);\n    return shade(light, light1, normal, ray, temp);\n  }\n}\n\nvec3 shade1(Light light, Light light1, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer1(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.333333333333333, 0.98, 1.0);\n    return shade1(light, light1, normal, ray, temp);\n  }\n}\n\nvec3 shade2(Light light, Light light1, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer2(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.75, 0.98, 1.0);\n    return shade2(light, light1, normal, ray, temp);\n  }\n}\n\nuint union_color_index1(vec3 light_dir, vec3 p) {\n  float nearest = move_outer2(light_dir, p);\n  uint nearest_index = 0u;\n  float d = move_outer2(light_dir, p);\n  if (d < 0.0) return 0u;\n  if (d < nearest) {\n    nearest = d;\n    nearest_index = 0u;\n  }\n  float d1 = sdf_round_cone_y(3.0, 10.0, 1.5, p);\n  if (d1 < 0.0) return 1u;\n  if (d1 < nearest) {\n    nearest = d1;\n    nearest_index = 1u;\n  }\n  return nearest_index;\n}\n\nuint union_color_index2(vec3 p) {\n  float nearest = sdf_ellipsoid(vec3(2.0, 1.0, 2.0), p);\n  uint nearest_index = 0u;\n  float d = sdf_ellipsoid(vec3(2.0, 1.0, 2.0), p);\n  if (d < 0.0) return 0u;\n  if (d < nearest) {\n    nearest = d;\n    nearest_index = 0u;\n  }\n  float d1 = sdf_round_cone_y(3.0, -6.0, 0.5, p);\n  if (d1 < 0.0) return 1u;\n  if (d1 < nearest) {\n    nearest = d1;\n    nearest_index = 1u;\n  }\n  return nearest_index;\n}\n\nvec3 shade3(Light light, Light light1, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer3(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.0, 0.5, 0.5);\n    return shade3(light, light1, normal, ray, temp);\n  }\n}\n\nvec3 union_color(vec3 flashlight_color, Light light, Light light1, vec3 normal, vec3 p, Ray ray) {\n  switch (union_color_index2(p)) {\n  case 0u: return flashlight_color;\n  case 1u: return shade_outer3(light, light1, normal, ray);\n  }\n  return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 move_outer7(vec3 flashlight_color, Light light, Light light1, vec3 normal, vec3 p, Ray ray) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 3.0);\n    return union_color(flashlight_color, light, light1, normal, p1, ray);\n  }\n}\n\nvec3 align_outer1(vec3 flashlight_color, Light light, Light light1, vec3 light_dir, vec3 normal, vec3 p, Ray ray) {\n  {\n    vec3 p1 = alignment_matrix(light_dir, vec3(0.0, 1.0, 0.0)) * p;\n    return move_outer7(flashlight_color, light, light1, normal, p1, ray);\n  }\n}\n\nvec3 move_outer8(vec3 flashlight_color, Light light, Light light1, vec3 light_dir, vec3 normal, vec3 p, Ray ray) {\n  {\n    vec3 p1 = p - (vec3(0.0, 1.0, 0.0) * 10.0);\n    return align_outer1(flashlight_color, light, light1, light_dir, normal, p1, ray);\n  }\n}\n\nvec3 shade4(Light light, Light light1, vec3 normal, Ray ray, vec3 temp) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, temp, 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, temp, 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer4(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    vec3 temp = hsv(0.0, 0.5, 0.5);\n    return shade4(light, light1, normal, ray, temp);\n  }\n}\n\nvec3 union_color1(vec3 flashlight_color, Light light, Light light1, vec3 light_dir, vec3 normal, vec3 p, Ray ray) {\n  switch (union_color_index1(light_dir, p)) {\n  case 0u: return move_outer8(flashlight_color, light, light1, light_dir, normal, p, ray);\n  case 1u: return shade_outer4(light, light1, normal, ray);\n  }\n  return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 move_outer9(vec3 flashlight_color, Light light, Light light1, vec3 light_dir, vec3 normal, vec3 p, vec3 player_pos, Ray ray) {\n  {\n    vec3 p1 = p - (player_pos * 1.0);\n    return union_color1(flashlight_color, light, light1, light_dir, normal, p1, ray);\n  }\n}\n\nvec3 shade5(Light light, Light light1, vec3 normal, Ray ray) {\n  vec3 result = vec3(0.0);\n  result += blinn_phong(light, vec3(1.0, 1.0, 1.0), 0.25, 10.0, normal, ray);\n  result += blinn_phong(light1, vec3(1.0, 1.0, 1.0), 0.25, 10.0, normal, ray);\n  return result;\n}\n\nvec3 shade_outer5(Light light, Light light1, vec3 normal, Ray ray) {\n  {\n    return shade5(light, light1, normal, ray);\n  }\n}\n\nvec3 union_color2(vec3 flashlight_color, Light light, Light light1, vec3 light_dir, vec3 normal, vec3 p, vec3 player_pos, Ray ray, float t) {\n  switch (union_color_index(light_dir, p, player_pos, t)) {\n  case 0u: return shade_outer(light, light1, normal, ray);\n  case 1u: return shade_outer1(light, light1, normal, ray);\n  case 2u: return shade_outer2(light, light1, normal, ray);\n  case 3u: return mix(hsv(0.0, 0.98, 1.0), hsv(0.166666666666667, 0.98, 1.0), (normal.y + 1.0) * 0.5);\n  case 4u: return move_outer9(flashlight_color, light, light1, light_dir, normal, p, player_pos, ray);\n  case 5u: return shade_outer5(light, light1, normal, ray);\n  }\n  return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 hoist_outer1(vec3 P, vec3 light_target, vec3 normal, vec3 p, vec3 player_pos, Ray ray, float t) {\n  {\n    vec3 light_dir = normalize(light_target - (vec3(0.0, 8.0, 0.0) + player_pos));\n    float occlusion = calculate_occlusion(8u, 5.0, normal, P, light_target, p, player_pos, t);\n    Light light = do_5(P, light_target, normal, occlusion, p, player_pos, t);\n    vec3 flashlight_color = mix(hsv(0.166666666666667, 0.98, 1.0), vec3(1.0, 1.0, 1.0), 0.5);\n    vec3 flashlight = ((light_dir * 6.0) + vec3(0.0, 8.0, 0.0)) + player_pos;\n    Light light1 = do_6(P, flashlight, flashlight_color, light_dir, light_target, normal, player_pos, t);\n    return union_color2(flashlight_color, light, light1, light_dir, normal, p, player_pos, ray, t);\n  }\n}\n\nvec4 sample_(vec2 Frag_Coord, int camera_type, vec2 frag_coord, vec2 free_camera_orbit, vec3 free_camera_target, float free_camera_zoom, vec3 light_target, vec3 player_pos, vec2 resolution, float t) {\n  Ray ray_star = Ray(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n  vec3 ortho_quad = vec3(1024.0, (frag_coord * 212.077343935025) * free_camera_zoom);\n  float ortho_scale = 212.077343935025 * free_camera_zoom;\n  float fov = 0.0;\n  switch (camera_type) {\n  case 0: OrthographicCamera camera = OrthographicCamera(round(vec3(100.0, 100.0, 100.0) + player_pos), normalize(player_pos - round(vec3(100.0, 100.0, 100.0) + player_pos)), vec3(0.0, 1.0, 0.0), 106.0);\n  ray_star = let_outer1(camera, frag_coord);\n  ortho_scale = camera.scale;\n  break;\n  case 1: {\n    mat3 camera_rotation_matrix = rotation_y(6.28318530717959 * free_camera_orbit.x) * rotation_x(6.28318530717959 * free_camera_orbit.y);\n    ray_star = Ray((camera_rotation_matrix * vec3(0.0, 0.0, 512.0 * free_camera_zoom)) + free_camera_target, camera_rotation_matrix * (perspective_vector(45.0, frag_coord) * vec3(1.0, 1.0, -1.0)));\n    fov = 45.0;\n    break;\n  }\n  case 2: {\n    ray_star = Ray(ortho_quad.yxz + free_camera_target, vec3(0.0, -1.0, 0.0));\n    break;\n  }\n  case 3: {\n    ray_star = Ray(ortho_quad.yzx + free_camera_target, vec3(0.0, 0.0, -1.0));\n    break;\n  }\n  case 4: {\n    ray_star = Ray(ortho_quad.xzy + free_camera_target, vec3(-1.0, 0.0, 0.0));\n    break;\n  }\n  }\n  uint steps = 0u;\n  {\n    Ray ray = ray_star;\n    float depth = march(steps, light_target, player_pos, ray, t);\n    vec3 P = ray.origin + (ray.direction * depth);\n    vec3 p = P;\n    float dist = nearest_distance(light_target, p, player_pos, t);\n    vec3 normal = normalize((vec2(1.0, -1.0).xyy * with_outer1(light_target, p, player_pos, t)) + (vec2(1.0, -1.0).yyx * with_outer2(light_target, p, player_pos, t)) + (vec2(1.0, -1.0).yxy * with_outer3(light_target, p, player_pos, t)) + (vec2(1.0, -1.0).xxx * with_outer4(light_target, p, player_pos, t)));\n    vec4 color = vec4(0.0);\n    color = (dist >= 10.0) ? vec4(do_4(Frag_Coord, resolution), 1.0) : vec4(hoist_outer1(P, light_target, normal, p, player_pos, ray, t), 1.0);\n    return color;\n  }\n}\n\nvec3 pow_(vec3 v, float e) {\n  return pow(v, vec3(e));\n}\n\nvoid main() {\n  const float gamma = 2.2;\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  float alpha = 0.0;\n  const uint aa_grid_size = 1u;\n  const float aa_sample_width = 1.0 / float(1u + aa_grid_size);\n  const vec2 pixel_origin = vec2(0.5, 0.5);\n  vec2 local_frag_coord = gl_FragCoord.xy - viewport.xy;\n  mat2 rotation = rotation_2d(0.2);\n  for (uint y = 1u; y <= aa_grid_size; ++y) {\n    for (uint x = 1u; x <= aa_grid_size; ++x) {\n      vec2 sample_offset = (aa_sample_width * vec2(float(x), float(y))) - pixel_origin;\n      sample_offset = rotation * sample_offset;\n      sample_offset = fract(sample_offset + pixel_origin) - pixel_origin;\n      {\n        vec2 Frag_Coord = local_frag_coord + sample_offset;\n        vec2 resolution = viewport.zw;\n        vec2 frag_coord = ((Frag_Coord - (0.5 * resolution)) / max_(resolution)) * 2.0;\n        vec4 this_sample = clamp(sample_(Frag_Coord, camera_type, frag_coord, free_camera_orbit, free_camera_target, free_camera_zoom, light_target, player_pos, resolution, t), 0.0, 1.0);\n        color += this_sample.rgb * this_sample.a;\n        alpha += this_sample.a;\n      }\n    }\n  }\n  if (alpha > 0.0) {\n    color = color / alpha;\n    alpha /= float(aa_grid_size * aa_grid_size);\n  }\n  frag_color = vec4(pow_(color, 1.0 / gamma), alpha);\n}\n",
      animate: true,
      uniforms: {
        player_pos: "vec3",
        light_target: "vec3"
      }
    });
    let player_pos = [34, 0, 0];
    let light_target = [50, 0, -50];
    bauble.set({player_pos, light_target});
    let mouseAt = [1, 0];
    canvas.addEventListener('mousemove', (e) => {
      const bounds = canvas.getBoundingClientRect();
      mouseAt = [(e.clientX - bounds.left) / bounds.width * 2 - 1, (e.clientY - bounds.top) / bounds.height * 2 - 1];
    });

    let keysDown = {};
    canvas.addEventListener('keydown', (e) => { keysDown[e.code] = true; });
    canvas.addEventListener('keyup', (e) => { keysDown[e.code] = false; });
    canvas.addEventListener('blur', (e) => { keysDown = {}; });

    let isPaused = false;
    const gameLoop = () => {
      if (!isPaused) {
        const move = [0, 0];

        if (keysDown.KeyA) { move[0] -= 1; move[1] += 1; }
        if (keysDown.KeyW) { move[0] -= 1; move[1] -= 1; }
        if (keysDown.KeyS) { move[0] += 1; move[1] += 1; }
        if (keysDown.KeyD) { move[0] += 1; move[1] -= 1; }
        const norm = Math.sqrt(move[0] * move[0] + move[1] * move[1]);

        if (norm > 0) {
          player_pos[0] += move[0] / norm;
          player_pos[2] += move[1] / norm;
          bauble.set({player_pos});
        }

        light_target = [mouseAt[0] + mouseAt[1], 0, -mouseAt[0] + mouseAt[1]];
        const orthoScale = 106;
        light_target[0] *= orthoScale;
        light_target[2] *= orthoScale;
        light_target = [light_target[0] + player_pos[0], 0, light_target[2] + player_pos[2]];
        bauble.set({light_target});
      }
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);

    return (play) => { isPaused = !play; bauble.togglePlay(play); };
  }

  document.addEventListener('DOMContentLoaded', () => {
    balloonExample();
    const planetCanvas = document.getElementById('planet');
    let togglePlanetPlay = null;
    const planetIntersectionObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting && togglePlanetPlay == null) {
          togglePlanetPlay = planetExample(planetCanvas);
        }
        if (togglePlanetPlay != null) {
          togglePlanetPlay(entry.isIntersecting);
        }
      }
    });
    planetIntersectionObserver.observe(planetCanvas);

    const gameCanvas = document.getElementById('game');
    let toggleGamePlay = null;
    const gameIntersectionObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting && toggleGamePlay == null) {
          toggleGamePlay = gameExample(gameCanvas);
        }
        if (toggleGamePlay != null) {
          toggleGamePlay(entry.isIntersecting);
        }
      }
    });
    gameIntersectionObserver.observe(gameCanvas);
  });
}
EOF
)

# So SolidJS performs a top-level effect at load time that reads from
# the window. In a worker, this throws. So we don't perform the effect
# in a window.
sed -E "s/^delegateEvents/if (typeof window !== 'undefined') delegateEvents/" -i "$3"

# Similar, but this time it's emscripten that wants to read the current script path for some reason.
sed -E "s|document\.baseURI|(typeof document == 'undefined' ? 'https://example.org/' : document.baseURI)|" -i "$3"

cd ../studio

if [[ $mode == "prod" ]]; then
  ./node_modules/.bin/terser "$actual_outpath_jfc" -o "$actual_outpath_jfc"
fi
